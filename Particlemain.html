<!DOCTYPE HTML>
<html>
  <head>
    <style>
      body {
        background-color: black;
        margin: 0px;
        padding: 0px;
      }
    </style>
  </head>
  <body>
    <canvas id="myCanvas" width="640" height="640" style="border:1px solid #c3c3c3;"></canvas>
    <p id="test" style="color:white">Hello am I working ?</p>
    <p id="test2" style="color:white">Hello am I working ?</p>
    <button onclick="ReversePixels()" id="button1">Click to reverse image</button>
    <br>
    <p style="color:white">Move the slider to set gravity strength</p>
    <input type="range" id="Gforce" max="500.0" min="10.0">
    <br>
    <p style="color:white">Move the slider to set gravity centre X</p>
    <input type="range" id="GcenX" max="640" min="0">
    <br>
    <p style="color:white">Move the slider to set gravity centre Y</p>
    <input type="range" id="GcenY" max="640" min="0">
    <p style="color:white">Move the slider to set X viscosity</p>
    <input type="range" id="ViscX" max="0.1" min="0.01" step="0.01">
    <p style="color:white">Move the slider to set Y viscosity</p>
    <input type="range" id="ViscY" max="0.1" min="0.01" step="0.01">
    <p style="color:white">Move the slider to set wall bounce</p>
    <input type="range" id="Bounce" max="1.00" min="0.05" step="0.05">
    <script>
            /* Particle simulation using HTML5 Canvas, with adjustable physics, Dec '15 */
      
      window.requestAnimFrame = (function(callback) {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
        function(callback) {
          window.setTimeout(callback, 1000 / 60);
        };
      })();

      var canvas = document.getElementById('myCanvas');
      var context = canvas.getContext('2d');
      var totPart = 5000; // MaxParticles
      

      // Array of Squares, sooo squareeee!!! 
      var myArraySquares = [];
      var str="";
      var obj={};
      var colrswitch;
      var colstr="";
      var Fcentre={Xo: 120, Yo: 450};   // Initial value of gravity centre position
      var tst,tst2,mss;

      // Array of colours 
      colors=["#FF0000","#00FF00", "#0000FF", "#5555AA", "#00ABD0", "#FF00AA"]; 
      masses=[1,2,3,4,5,6];
       
      // fill the array with squares with positions, velocites and masses!
      fillTheArray();
     
      str +="Type of Canvas.height is " + typeof(canvas.height);
      document.getElementById("test").innerHTML=str;
      
      

        function animate(canvas, context, startTime) {
        
        var gravity = document.getElementById("Gforce").value; 
        var gcenx = parseInt(document.getElementById("GcenX").value); 
        var gceny = parseInt(document.getElementById("GcenY").value); 
        var bounce = document.getElementById("Bounce").value;  // Bounce off walls
        var dragx = document.getElementById("ViscX").value; // Viscosity 
        var dragy = document.getElementById("ViscY").value;
        var oldX;
        var oldY;
        var velX;
        var velY;
        var newX;
        var newY;
        var Forcex,quadrX=1.0;
        var Forcey,quadrY=1.0;
        var Fdis, Fang;
        var weight;
        var strg="";
        var time = (new Date()).getTime() - startTime;
       
        Fcentre.Xo=gcenx; 
        Fcentre.Yo=gceny;
 
        var linearSpeed = 100;
        // pixels / second
         
         strg ="Bounce is " + bounce + " ViscX is " + dragx + " ViscY is " + dragy;
         document.getElementById("test2").innerHTML=strg;
        
        for (var i = 0; i < totPart; i++) {   //Main animation loop
          weight=myArraySquares[i].mass;
          oldX = myArraySquares[i].x;
          oldY = myArraySquares[i].y;
          velX = myArraySquares[i].vx; // * time / 1000;
          velY = myArraySquares[i].vy; // * time / 1000;
          
          Fdis = calcDistance(oldX, oldY);
          Fang = calcAngle(oldX, oldY);
         
          if((gcenx-oldX) < 0){
               quadrX=-1.0; }

          /* if((gceny-oldY) < 0){
               quadrY=-1.0; } */

          Forcex = (1.0)*quadrX*(gravity/(Fdis*Fdis)*Math.sin(Fang)) + ((-1.0)* dragx * velX);
          Forcey = (1.0)*quadrY*(gravity/(Fdis*Fdis)*Math.cos(Fang)) + ((-1.0)* dragy * velY);
          
          myArraySquares[i].vx = velX + (Forcex/weight);
          myArraySquares[i].vy = velY + (Forcey/weight);
          
          newX = oldX + velX;
          newY = oldY + velY;
          
          myArraySquares[i].x = newX;
          myArraySquares[i].y = newY;
          
          
        
         // Behaviour at the walls
 
        if ((myArraySquares[i].x >= canvas.width) || (myArraySquares[i].x <= 0)) { 
        myArraySquares[i].vx = (velX*bounce*(-1.0));
                        }

       
        if ((myArraySquares[i].y >= canvas.height) || (myArraySquares[i].y <= 0)) { 
        myArraySquares[i].vy = (velX*bounce*(-1.0));
                        }
        


                                          }  //Close main animation loop
       
       
       // Clear the Screen between frames! 
       
      //context.clearRect(0, 0, canvas.width, canvas.height);
      
        // Draw the screen! 
       drawRectangle(context);
      // drawCentreRect(myRectangle);
        // request new frame
        requestAnimFrame(function() {
          animate(canvas, context, startTime);
        });
      }
       

      var myRectangle = { x:320, y:320, width: 150, height: 100, borderWidth:2, colr: "#F00FF0" };
      

      // wait 100 miliseconds second before starting animation
      setTimeout(function() {
        var startTime = (new Date()).getTime();
        animate(canvas, context, startTime);
      }, 100);
      
      
      
      // Function that populates the array of particle objects
     function fillTheArray(){
      for (var i = 0; i < totPart; i++) {
      colrswitch = i % colors.length;
      switch (colrswitch) {
      case 0:
      colstr = colors[0];
      mss = masses[0];
      break;
      case 1:
      colstr = colors[1];
      mss = masses[1];
      break;
      case 2:
      colstr  = colors[2];
      mss = masses[2];
      break;
      case 3:
      colstr  = colors[3];
      mss = masses[3];
      break;
      case 4:
      colstr  = colors[4];
      mss = masses[4];
      break;
      case 5:
      colstr  = colors[5];
      mss = masses[5];
      break;
      }      
      

      obj={x:parseInt(Math.random()*canvas.width),                               // (parseInt(i/canvas.width))+160
           y: parseInt(Math.random()*canvas.height),                             //  ((i % canvas.width)),
           vx:0,                                                               // (0.5*(10-(Math.random()*20)))
           vy:0,  
           Fx:0,
           Fy:0, 
           mass: mss,                                                 //1,(Math.random()*2)
           width:1, 
           height:1, 
           borderWidth:0, 
           colr: colstr};
     
      myArraySquares.push(obj);     
                                         } // close loop
  
      }
     
     // Drawing function for individual squares
     function drawRectangle(context) {
        for (var i = 0; i < totPart; i++) {
        //context.beginPath();
        context.fillStyle = myArraySquares[i].colr;
        context.fillRect(myArraySquares[i].x, myArraySquares[i].y, myArraySquares[i].width, myArraySquares[i].height);
        //context.rect(myArraySquares[i].x, myArraySquares[i].y, myArraySquares[i].width, myArraySquares[i].height);
        //context.fill();
        //context.lineWidth = myArraySquares[i].borderWidth;
       // context.strokeStyle = 'black';
       // context.stroke();
        }
      }

      function drawCentreRect(rectangle){
      context.fillStyle = rectangle.colr;
      context.fillRect(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
      }

  
      // Functions calculate distance and angle of each particle relative to gravity centre 
      function calcDistance(inputx, inputy){
 
        var inputx,inputy,xbit,ybit;
        var distance;
        
        xbit=Math.abs((inputx-Fcentre.Xo)*(inputx-Fcentre.Xo));
        ybit=Math.abs((inputy-Fcentre.Yo)*(inputy-Fcentre.Yo));
        
        distance=Math.sqrt(xbit+ybit);
        
        return distance;  
         
      }
      function calcAngle(inputx, inputy){

        var xbit,ybit;
        var angle;
        
        xbit=(Fcentre.Xo-inputx);
        ybit=(Fcentre.Yo-inputy);
        
        angle=Math.atan(ybit/xbit);
        
        return angle;
        
      } 
      function ReversePixels(){
    var canv1 = document.getElementById("myCanvas");
    var ctx = canv1.getContext("2d"); 
    
    var arrwidth=canv1.width;
    var arrheight=canv1.height;
    var x,y,inpos,outpos;
    Canv1Data=ctx.getImageData(0,0,arrwidth,arrheight);
    Canv2Data=ctx.getImageData(0,0,arrwidth,arrheight);
    for (y = 0; y < arrheight; y++) {
        inpos = y * arrwidth * 4; // *4 for 4 ints per pixel
        outpos = inpos
        for (x = 0; x < arrwidth; x++) {
            r = Canv1Data.data[inpos++];  
            g = Canv1Data.data[inpos++];  
            b = Canv1Data.data[inpos++]; 
            a = Canv1Data.data[inpos++];

           
            Canv1Data.data[outpos++] = (255-r);
            Canv1Data.data[outpos++] = (255-g);
            Canv1Data.data[outpos++] = b;
            Canv1Data.data[outpos++] = a;
          
           
        }
    }
   
   ctx.putImageData(Canv1Data, 0, 0);    
} 

    </script>
  </body>
</html>      




